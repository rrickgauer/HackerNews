(function(){'use strict';class ApiWrapper
{
    static async getTopStoriesIds() {
        let response = await fetch(ApiWrapper.URLS.TOP);
        return response.json();
    }

    static async getStory(id) {
        const urlStory = ApiWrapper.getStoryUrl(id);
        const response = await fetch(urlStory);
        return response.json();
    }


    static getStoryUrl(id) {
        let url = `${ApiWrapper.URLS.STORY}${id}.json`;
        return url;
    }

    static getUserUrl(userID) {
        return `${ApiWrapper.URL_USER_BASE}${userID}`;
    }

}



ApiWrapper.URL_BASE      = 'https://hacker-news.firebaseio.com/v0/';
ApiWrapper.URL_USER_BASE = 'https://news.ycombinator.com/user?id=';

ApiWrapper.URLS = {
    TOP  : ApiWrapper.URL_BASE + 'topstories.json',
    STORY: ApiWrapper.URL_BASE + 'item/',
};const DateTime = luxon.DateTime;class Dates
{   
    /**
     * Returns the time difference between a datetime and now.
     * 
     * @param {Constants.DateTime} a_dtDateTime - the datetime object
     * 
     * @returns {Object} diff - The point generated by the factory.
     * @returns {number} diff.years - Difference in years
     * @returns {number} diff.months - Difference in months
     * @returns {number} diff.days - Difference in days
     * @returns {number} diff.hours - Difference in hours
     * @returns {number} diff.minutes - Difference in minutes
     * @returns {number} diff.seconds - Difference in seconds
     */
    static getDiffNow(a_dtDateTime) {
        const diff = DateTime.now().diff(a_dtDateTime, Dates.DIFF_UNITS);
        return diff.values;
    }

    /**
     * Generate the date difference display string.
     */
    static getDiffDisplayString(a_dtDiff) {
        let numUnits = null;
        let unitType = null;
        
        if (a_dtDiff.days > 0) {
            numUnits = a_dtDiff.days;
            unitType = 'day';
        } else if (a_dtDiff.hours > 0) {
            numUnits = a_dtDiff.hours;
            unitType = 'hour';
        } else if (a_dtDiff.minutes > 1) {
            numUnits = a_dtDiff.minutes;
            unitType = 'minute';
        } 
        
        // item was created less than a minute ago
        if (null in [numUnits, unitType]) {
            return 'just now';
        }

        // append an s if there is more than 1 of the units
        if (numUnits > 1) {
            unitType += 's';
        }

        // throw them all together
        let result = `${numUnits} ${unitType} ago`;

        return result;
    }

}

/** Time difference units */
Dates.DIFF_UNITS = ["years", "months", "days", "hours", "minutes", "seconds"];class Comment
{   
    constructor(a_oApiResponse) {
        this.by = null;
        this.id = null;
        this.kids = null;
        this.parent = null;
        this.text = null;
        this.time = null;
        this.type = null;
        this.dt = null;

        for (const key of Object.keys(this)) {
            if (a_oApiResponse[key] != undefined) {
                this[key] = a_oApiResponse[key];
            }
        }

        this.dt = DateTime.fromSeconds(this.time);
        this.dtDiff = Dates.getDiffNow(this.dt);

        this.getHtml = this.getHtml.bind(this);
        this.getChildrenHtml = this.getChildrenHtml.bind(this);
        this.formatText = this.formatText.bind(this);
    }


    getHtml() {
        const self = this;

        const userUrl             = ApiWrapper.getUserUrl(self.by);
        const userUrlDisplay      = `<a class="text-reset" href=${userUrl}>${self.by}</a>`;
        const dateDisplay         = Dates.getDiffDisplayString(this.dtDiff);
        const kidsCommentsDisplay = this.getChildrenHtml();
        const displayText         = self.formatText();

        let html = `<hr>
        <li class="comment-item">
            <div class="d-flex">
                <p class="comment-item-meta">
                    <small class="text-muted">
                        <span>${userUrlDisplay} &#183; ${dateDisplay}</span> &#183; 
                        <a href="#" class="text-reset comment-item-btn-toggle-thread">Hide</a>
                    </small>
                </p>
            </div>

            <div class="comment-item-thread">
                <div class="comment-item-text">${displayText}</div>
                <ul class="list-comments list-unstyled">${kidsCommentsDisplay}</ul>
            </div>
        </li>`;

        return html;
    }

    getChildrenHtml() {
        let kidsCommentsHtml = '';

        if (this.kids == null) {
            return kidsCommentsHtml;
        }

        for (const kid of this.kids) {
            const kidComment = new Comment(kid);
            kidsCommentsHtml += kidComment.getHtml();
        }

        return kidsCommentsHtml;
    }

    /**
     * Wraps the first section of the comment text in a <p> tag.
     */
    formatText() {
        if (this.text == null) {
            return this.text;
        }

        // get the index of the first p tag
        const index = this.text.indexOf('<p>');

        // split up the string where the tag starts
        const startText = this.text.substring(0, index);
        const endText = this.text.substring(index);

        // wrap the initial section in a p tag
        const outText = `<p>${startText}</p>${endText}`;
        
        return outText;
    }
}class StoryComp
{

    constructor(a_apiResponse) {
        this.by          = null;
        this.descendants = null;
        this.id          = null;
        this.kids        = [];
        this.score       = null;
        this.time        = null;
        this.title       = null;
        this.type        = null;
        this.url         = null;

        for (const key of Object.keys(a_apiResponse)) {
            this[key] = a_apiResponse[key];
        }

        this.siteUrl = `https://news.ycombinator.com/item?id=${this.id}`;
        
        this.dt = DateTime.fromSeconds(this.time);
        this.dtDiff = Dates.getDiffNow(this.dt);

        this.getCardHtml = this.getCardHtml.bind(this);
        this.getListItemHtml = this.getListItemHtml.bind(this);
    }

    /**
     * Generate the card html
     * @returns Story card html string
     */
    getCardHtml() {
        const url = this.url == null ? this.siteUrl : this.url;
        const dtDisplay = Dates.getDiffDisplayString(this.dtDiff);

        // add commas to score and descendants
        const scoreDisplay = this.score.toLocaleString();
        const descendantsDisplay = this.descendants.toLocaleString();

        let html = `
        <div class="${StoryComp.StoryItemClass} card ${StoryComp.StoryCardClass} custom-shadow" data-id=${this.id}>
            <div class="card-body">
                <h5 class="card-title"><a href="${url}" target="_blank" class="card-story-link">${this.title}</a></h5>
                <p class="text-muted"><small>${dtDisplay}</small></p>
                <p class="text-muted"><i class='bx bxs-user'></i>&nbsp;${this.by}</p>
            </div>
            <div class="card-footer px-4">
                <div class="d-flex align-baseline justify-content-between">
                    <span><i class='bx bx-like'></i>&nbsp;${scoreDisplay}</span>
                    <span><i class='bx bx-comment-detail'></i>&nbsp;${descendantsDisplay}</span>
                </div>
            </div>
        </div>`;

        return html;
    }

    getListItemHtml() {
        const url = this.url == null ? this.siteUrl : this.url;
        const dtDisplay = Dates.getDiffDisplayString(this.dtDiff);

        let html = `
        <li class="${StoryComp.StoryItemClass} ${StoryComp.StoryListItemClass} list-group-item" data-id=${this.id}>
            <h5 class="card-title"><a href="${url}" target="_blank" class="card-story-link">${this.title}</a></h5>
            <p class="text-muted"><small>${dtDisplay}</small></p>
            <p class="text-muted"><i class='bx bxs-user'></i>&nbsp;${this.by}</p>
            <div class="d-flex align-baseline">
                <span class="mr-3"><i class='bx bx-like'></i>&nbsp;${this.score}</span>
                <span><i class='bx bx-comment-detail'></i>&nbsp;${this.descendants}</span>
            </div>
        </li>`;

        return html;
    }
}



StoryComp.StoryItemClass     = 'story-item';
StoryComp.StoryCardClass     = 'story-item-card';
StoryComp.StoryListItemClass = 'story-item-list-item';class StoryComments
{
    /**
     * @constructor
     * @param {number} a_iStoryID - story id
     */
    constructor(a_iStoryID) {
        this.comments = {};
        this.storyID = a_iStoryID;

        this.displayStoryMetadata = this.displayStoryMetadata.bind(this);
        this.fetchStoryData       = this.fetchStoryData.bind(this);
        this.fetchAllComments     = this.fetchAllComments.bind(this);
        this.displayComments      = this.displayComments.bind(this);
    }

    /**
     * Retrieve the story data
     * 
     * @param {number} a_iStoryID - story id
     */
    async fetchStoryData() {
        // fetch the story metadata
        const storyApiResponse = await ApiWrapper.getStory(this.storyID);
        const storyComp = new StoryComp(storyApiResponse);

        
        // display the metadata
        this.displayStoryMetadata(storyComp);

        // fetch all the story comments
        this.comments = storyComp;
        await this.fetchAllComments(this.comments);
        this.comments = this.comments.kids;

        // display the story comments
        this.displayComments();
    }


    /**
     * Display story metadata on the page
     * 
     * @param {StoryComp} a_oStoryMetadata - Story comp object
     */
    displayStoryMetadata(a_oStoryMetadata) {
        $('title').text(a_oStoryMetadata.title);
    }

    /**
     * Display the top level comments  
     * 
     * @param {StoryComp} storyComp the story
     */
    async fetchAllComments(storyComp) {

        if (!storyComp.hasOwnProperty('kids')) {    
            return;
        }

        const promiseList = [];

        for(const commentID of storyComp.kids) {
            promiseList.push(ApiWrapper.getStory(commentID));
        }

        storyComp.kids = await Promise.all(promiseList);

        for (let count = 0; count < storyComp.kids.length; count++) {
            await this.fetchAllComments(storyComp.kids[count]);
        }
    }

    /**
     * Display the comments
     */
    displayComments() {
        let html = '';

        for (const comment of this.comments) {
            const commentObj = new Comment(comment);
            html += commentObj.getHtml();
        }

        // display the html
        // make all links found within the comments section open a new tab
        $('#comments-list').html(html).find('a').attr("target", "_blank");
    }

}/**
 * Class to display the metadata for a story.
 */
class StoryMeta
{

    /**
     * Constructor
     * @param {number} a_iStoryID - story ID
     */
    constructor(a_iStoryID) {
        this.storyID = a_iStoryID;

        // init everything to null before we fetch the data
        this.title         = null;
        this.countComments = null;
        this.countLikes    = null;
        this.date          = null;
        this.dateDiff      = null;
        this.linkStory     = null;
        this.linkSite      = null;


        // bind the object's methods
        this.loadAndDisplayData   = this.loadAndDisplayData.bind(this);
        this.displayData          = this.displayData.bind(this);
        this.displayTitle         = this.displayTitle.bind(this);
        this.displayCountComments = this.displayCountComments.bind(this);
        this.displayCountLikes    = this.displayCountLikes.bind(this);
        this.displayDate          = this.displayDate.bind(this);
        this.displayLinkStory     = this.displayLinkStory.bind(this);
        this.displayLinkSite      = this.displayLinkSite.bind(this);
        this.setLink              = this.setLink.bind(this);
    }

    /**
     * Load the metadata then display it.
     */
     async loadAndDisplayData() {
        // fetch the story metadata
        const storyApiResponse = await ApiWrapper.getStory(this.storyID);
        const storyComp = new StoryComp(storyApiResponse);

        // set the appropriate fields
        this.title         = storyComp.title;
        this.countComments = storyComp.descendants;
        this.countLikes    = storyComp.score;
        this.date          = storyComp.dt;
        this.dateDiff      = storyComp.dtDiff;
        this.linkStory     = storyComp.url;
        this.linkSite      = storyComp.siteUrl;

        // now display it
        this.displayData();

    }

    /**
     * Display the data
     */
    displayData() {
        
        this.displayTitle();
        this.displayCountComments();
        this.displayCountLikes();
        this.displayDate();
        this.displayLinkStory();
        this.displayLinkSite();
    }

    /**
     * Display the title
     */
    displayTitle() {
        if (this.title == null) {
            return;
        }

        $(StoryMeta.TITLE).text(this.title).removeClass('skeleton-text skeleton-effect-wave');
    }

    /**
     * Display the comment count
     */
    displayCountComments() {
        if (this.countComments == null) {
            return;
        }

        const countCommentsText = `${this.countComments} comments`;
        $(StoryMeta.COUNT_COMMENTS).text(countCommentsText);
    }

    /**
     * Display the number of likes
     */
    displayCountLikes() {
        if (this.countLikes == null) {
            return;
        }

        const countLikesText = `${this.countLikes} likes`;
        $(StoryMeta.COUNT_LIKES).text(countLikesText);
    }

    /**
     * Display the story date
     */
    displayDate() {
        const dateDiffString = Dates.getDiffDisplayString(this.dateDiff);
        $(StoryMeta.DATE).text(dateDiffString);
    }

    /**
     * Set the link to the story url
     */
    displayLinkStory() {
        this.setLink(this.linkStory, StoryMeta.LINK_STORY);
    }

    /**
     * Set the link to the hackernews post
     */
    displayLinkSite() {
        this.setLink(this.linkSite, StoryMeta.LINK_SITE);
    }


    /**
     * Set the specified link value
     * @param {string} a_strValue - url
     * @param {string} a_strSelector - html element link to set
     * @returns void
     */
    setLink(a_strValue, a_strSelector) {
        if (a_strValue == null) {
            return;
        }

        $(a_strSelector).attr('href', a_strValue);
        $(a_strSelector).removeClass('disabled');
    }
}



StoryMeta.CONTAINER      = '#meta-container';
StoryMeta.TITLE          = '#meta-title';
StoryMeta.COUNT_COMMENTS = '#meta-count-comments';
StoryMeta.COUNT_LIKES    = '#meta-count-likes';
StoryMeta.DATE           = '#meta-date';
StoryMeta.LINK_STORY     = '#meta-link-story';
StoryMeta.LINK_SITE      = '#meta-link-site';/**
 * This class parses the current url.
 */
class UrlParser
{
    constructor(a_strUrl=null) {
        if (a_strUrl == undefined || a_strUrl == null) {
            this.url = window.location;
        }

        this.queryString = window.location.search;
        this.urlParms = new URLSearchParams(this.queryString);
        
        this.url = new URL(window.location);

        this.getQueryParm = this.getQueryParm.bind(this);
    }

    /**
     * Get the value of the given url query parm key
     * @param {string} a_strKey - url query parm key
     * @returns the value of the key 
     */
    getQueryParm(a_strKey) {
        return this.urlParms.get(a_strKey);
    }

    /**
     * Get the value url path
     * 
     * @param {number} index - path index
     * @returns string
     */
    getUrlPathSectionValue(index) {
        const pathSections = this.url.pathname.split('/');
        return pathSections[index + 1];
    }
}class Utilities 
{
    
    /**************************************************
    Enable the scroll button on the current page.
    ***************************************************/
    static enableJumpButton() {
        const className = '.btn-scroll-top';

        $(className).on('click', function() {
            document.body.scrollTop = 0; // For Safari
            document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
        });
        
        const scrollBtn = $(className);
        
        $(window).on('scroll', function() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                $(scrollBtn).removeClass('d-none');
            } else {
                $(scrollBtn).addClass('d-none');
            }
        });
    }
}const eMetaIDs = {
    container: '#meta-container',
    title: '#meta-title',
    countComments: '#meta-count-comments',
    countLikes: '#meta-count-likes',
    date: '#meta-date',
    linkStory: '#meta-link-story',
    linkSite: '#meta-link-site',
};


const eCommentsContainer = '#comments-list';

const eComments = {
    item: '.comment-item',
    toggleButton: '.comment-item-btn-toggle-thread',
    meta: '.comment-item-meta',
    thread: '.comment-item-thread',
    text: '.comment-item-text',
    visibilityClass: 'comment-item-hidden',
};const mUrlParser = new UrlParser();
const mStoryID = mUrlParser.getUrlPathSectionValue(1);

const mStoryMeta = new StoryMeta(mStoryID);
let mStoryComments = new StoryComments(mStoryID, eMetaIDs.title);


// main logic
$(document).ready(function() {
    mStoryMeta.loadAndDisplayData();
    mStoryComments.fetchStoryData();
    addListeners();
    Utilities.enableJumpButton();
});


/**
 * Add the event listeners to the page elements
 */
function addListeners() {
    $(eCommentsContainer).on('click', eComments.toggleButton, function(e) {
        e.preventDefault();
        toggleCommentVisibility(this);
    });
}


/**
 * Show/hide a comment thread actions
 */
function toggleCommentVisibility(a_eCommentItemButton) {
    const eComment = $(a_eCommentItemButton).closest(eComments.item);

    // toggle comment visibility
    $(eComment).toggleClass(eComments.visibilityClass);

    // update the button text to show or hide
    const btnText = $(eComment).hasClass(eComments.visibilityClass) ? 'Show' : 'Hide';
    $(a_eCommentItemButton).text(btnText);
}})();//# sourceMappingURL=story.bundle.js.map
